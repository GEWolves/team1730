"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getElementInspect = exports.getNamedFiber = exports.gotoEditor = exports.getElementCodeInfo = exports.getReferenceFiber = exports.getCodeInfoFromFiber = exports.getCodeInfoFromProps = exports.getCodeInfoFromDebugSource = void 0;
const launchEditorEndpoint_1 = __importDefault(require("react-dev-utils/launchEditorEndpoint"));
const querystring_1 = __importDefault(require("querystring"));
const fiber_1 = require("./fiber");
/**
 * react fiber property `_debugSource` created by `@babel/plugin-transform-react-jsx-source`
 *     https://github.com/babel/babel/blob/main/packages/babel-plugin-transform-react-jsx-source/src/index.js#L51
 *
 * and injected `__source` property used by `React.createElement`, then pass to `ReactElement`
 *     https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js#L350-L374
 *     https://github.com/facebook/react/blob/master/packages/react/src/ReactElement.js#L189
 *
 * finally, used by `createFiberFromElement` to become a fiber property `_debugSource`.
 *     https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.new.js#L634
 */
const getCodeInfoFromDebugSource = (fiber) => {
    if (!(fiber === null || fiber === void 0 ? void 0 : fiber._debugSource))
        return undefined;
    const { fileName, lineNumber, columnNumber, } = fiber._debugSource;
    if (fileName && lineNumber) {
        return {
            lineNumber: String(lineNumber),
            columnNumber: String(columnNumber !== null && columnNumber !== void 0 ? columnNumber : 1),
            /**
             * fileName in debugSource is absolutely
             */
            absolutePath: fileName,
        };
    }
    return undefined;
};
exports.getCodeInfoFromDebugSource = getCodeInfoFromDebugSource;
/**
 * code location data-attribute props inject by `react-dev-inspector/plugins/babel`
 */
const getCodeInfoFromProps = (fiber) => {
    if (!(fiber === null || fiber === void 0 ? void 0 : fiber.pendingProps))
        return undefined;
    const { 'data-inspector-line': lineNumber, 'data-inspector-column': columnNumber, 'data-inspector-relative-path': relativePath, } = fiber.pendingProps;
    if (lineNumber && columnNumber && relativePath) {
        return {
            lineNumber,
            columnNumber,
            relativePath,
        };
    }
    return undefined;
};
exports.getCodeInfoFromProps = getCodeInfoFromProps;
const getCodeInfoFromFiber = (fiber) => {
    var _a;
    return ((_a = (0, exports.getCodeInfoFromProps)(fiber)) !== null && _a !== void 0 ? _a : (0, exports.getCodeInfoFromDebugSource)(fiber));
};
exports.getCodeInfoFromFiber = getCodeInfoFromFiber;
/**
 * give a `base` dom fiber,
 * and will try to get the human friendly react component `reference` fiber from it;
 *
 * rules and examples see below:
 * *******************************************************
 *
 * if parent is html native tag, `reference` is considered to be as same as `base`
 *
 *  div                                       div
 *    └─ h1                                     └─ h1  (<--base) <--reference
 *      └─ span  (<--base) <--reference           └─ span
 *
 * *******************************************************
 *
 * if parent is NOT html native tag,
 *   and parent ONLY have one child (the `base` itself),
 *   then `reference` is considered to be the parent.
 *
 *  Title  <--reference                       Title
 *    └─ h1  (<--base)                          └─ h1  (<--base) <--reference
 *      └─ span                                 └─ span
 *                                              └─ div
 *
 * *******************************************************
 *
 * while follow the last one,
 *   "parent" is considered to skip continuous Provider/Customer/ForwardRef components
 *
 *  Title  <- reference                       Title  <- reference
 *    └─ TitleName [ForwardRef]                 └─ TitleName [ForwardRef]
 *      └─ Context.Customer                       └─ Context.Customer
 *         └─ Context.Customer                      └─ Context.Customer
 *          └─ h1  (<- base)                          └─ h1  (<- base)
 *            └─ span                             └─ span
 *                                                └─ div
 *
 *  Title
 *    └─ TitleName [ForwardRef]
 *      └─ Context.Customer
 *         └─ Context.Customer
 *          └─ h1  (<- base) <- reference
 *    └─ span
 *    └─ div
 */
const getReferenceFiber = (baseFiber) => {
    if (!baseFiber)
        return undefined;
    const directParent = (0, fiber_1.getDirectParentFiber)(baseFiber);
    if (!directParent)
        return undefined;
    const isParentNative = (0, fiber_1.isNativeTagFiber)(directParent);
    const isOnlyOneChild = !directParent.child.sibling;
    let referenceFiber = (!isParentNative && isOnlyOneChild)
        ? directParent
        : baseFiber;
    // fallback for cannot find code-info fiber when traverse to root
    const originReferenceFiber = referenceFiber;
    while (referenceFiber) {
        if ((0, exports.getCodeInfoFromFiber)(referenceFiber))
            return referenceFiber;
        referenceFiber = referenceFiber.return;
    }
    return originReferenceFiber;
};
exports.getReferenceFiber = getReferenceFiber;
const getElementCodeInfo = (element) => {
    const fiber = (0, fiber_1.getElementFiberUpward)(element);
    const referenceFiber = (0, exports.getReferenceFiber)(fiber);
    return (0, exports.getCodeInfoFromFiber)(referenceFiber);
};
exports.getElementCodeInfo = getElementCodeInfo;
const gotoEditor = (source) => {
    if (!source)
        return;
    const { lineNumber, columnNumber, relativePath, absolutePath, } = source;
    const isRelative = Boolean(relativePath);
    const launchParams = {
        fileName: isRelative ? relativePath : absolutePath,
        lineNumber,
        colNumber: columnNumber,
    };
    /**
     * api in 'react-dev-inspector/plugins/webpack/middlewares' launchEditorMiddleware
     */
    const apiRoute = isRelative
        ? `${launchEditorEndpoint_1.default}/relative`
        : launchEditorEndpoint_1.default;
    fetch(`${apiRoute}?${querystring_1.default.stringify(launchParams)}`);
};
exports.gotoEditor = gotoEditor;
const getNamedFiber = (baseFiber) => {
    var _a, _b;
    let fiber = baseFiber;
    // fallback for cannot find code-info fiber when traverse to root
    let originNamedFiber;
    while (fiber) {
        let parent = (_a = fiber.return) !== null && _a !== void 0 ? _a : undefined;
        let forwardParent;
        while ((0, fiber_1.isReactSymbolFiber)(parent)) {
            if ((0, fiber_1.isForwardRef)(parent)) {
                forwardParent = parent;
            }
            parent = (_b = parent === null || parent === void 0 ? void 0 : parent.return) !== null && _b !== void 0 ? _b : undefined;
        }
        if (forwardParent) {
            fiber = forwardParent;
        }
        if ((0, fiber_1.getFiberName)(fiber)) {
            if (!originNamedFiber)
                originNamedFiber = fiber;
            if ((0, exports.getCodeInfoFromFiber)(fiber))
                return fiber;
        }
        fiber = parent;
    }
    return originNamedFiber;
};
exports.getNamedFiber = getNamedFiber;
const getElementInspect = (element) => {
    const fiber = (0, fiber_1.getElementFiberUpward)(element);
    const referenceFiber = (0, exports.getReferenceFiber)(fiber);
    const namedFiber = (0, exports.getNamedFiber)(referenceFiber);
    const fiberName = (0, fiber_1.getFiberName)(namedFiber);
    const nodeName = element.nodeName.toLowerCase();
    const title = fiberName
        ? `${nodeName} in <${fiberName}>`
        : nodeName;
    return {
        fiber: referenceFiber,
        name: fiberName,
        title,
    };
};
exports.getElementInspect = getElementInspect;
